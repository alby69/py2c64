; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 10
; x2 = 20
; z = x1 + x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a1 = 5
; b = 3
; c = a1 * b + (a1 - b) // 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 250
; x2 = 10
; z = x1 + x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 10
; x2 = 0
; z = x1 // x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 10 # 00001010
; b = 5  # 00000101
; c = a ^ b # Expected result: 15 (00001111)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; val1 = 255 # 11111111 00000000
; val2 = 85  # 01010101 00000000
; # 255 (00FF) ^ 85 (0055) = 170 (00AA)
; res_xor = val1 ^ val2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 2 * 5
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; y = 10 // 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; z = 5 + 3.14
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3]
; for item in my_list:
;   x = item * 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; while i < 5:
;   i = i + 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; res = 0
; if x == 10:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; res = 0
; if x == 10:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; res = 0
; if x > 5:
;   res = 1
; else:
;   res = 2
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; res = 0
; if x > 5:
;   res = 1
; else:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 15
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_2
    JMP if_end_2
if_else_2:
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 7
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_2
    JMP if_end_2
if_else_2:
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 3
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_2
    JMP if_end_2
if_else_2:
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 12
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_2
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 8
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_2
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 5
; res = 0
; if x <= y:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 5
; res = 0
; if x < y:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; y = 5
; res = 0
; if x > 5:
;   if y < 10:
;     res = 1
;   else:
;     res = 2
; else:
;   res = 3
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_2
    JMP if_end_2
if_else_2:
if_end_2:
    JMP if_end_0
if_else_0:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if True:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if False:
;   res = 1
; else:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 10
; res = 0
; if x + 2 > y - 5:
;   res = 1
; # Expected: 7 > 5 -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; y = 1
; res = 0
; if x * 2 == y + 5:
;   res = 1
; # Expected: 6 == 6 -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; res = 0
; if not x:
;   res = 1
; # Expected: not 0 -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; res = 0
; if not x:
;   res = 1
; # Expected: not 5 -> False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 10
; res = 0
; if x > 0 and y > 0:
;   res = 1
; # Expected: True and True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if x > 0 and y > 0:
;   res = 1
; # Expected: True and False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 10
; res = 0
; if x > 0 and y > 0: # y > 0 should not be evaluated if the compiler is smart
;   res = 1
; # Expected: False and True -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if x > 0 or y > 0: # y > 0 should not be evaluated
;   res = 1
; # Expected: True or False -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 10
; res = 0
; if x > 0 or y > 0:
;   res = 1
; # Expected: False or True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 0
; res = 0
; if x > 0 or y > 0:
;   res = 1
; # Expected: False or False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if not (x == 0 and y == 0):
;   res = 1
; # Expected: not (False and True) -> not False -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 0
; res = 0
; if not (x > 0 or y > 0):
;   res = 1
; # Expected: not (False or False) -> not False -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if True and False:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 10
; b = 5
; res = 0
; if (a ^ b): # 10^5 = 15 (non-zero, quindi True)
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 7
; b = 7
; res = 0
; if (a ^ b): # 7^7 = 0 (zero, quindi False)
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; res = 0
; while i < 10:
;   res = res + i
;   i = i + 1
;   if i == 5:
;     break
; # Expected: res = 0+1+2+3+4 = 10, i = 5
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_2
if_end_2:
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; res = 0
; while i < 5:
;   i = i + 1
;   if i == 3:
;     continue
;   res = res + i
; # Expected: i=5, res = 1+2+4+5 = 12
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_2
if_end_2:
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3, 4, 5]
; res = 0
; for item in my_list:
;   if item == 4:
;     break
;   res = res + item
; # Expected: res = 1+2+3 = 6
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3, 4, 5]
; res = 0
; for item in my_list:
;   if item == 3:
;     continue
;   res = res + item
; # Expected: res = 1+2+4+5 = 12
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; outer_sum = 0
; my_list = [1, 2, 3]
; for x in my_list: # x = 1, 2, 3
;     outer_sum = outer_sum + x
;     y = 0
;     while y < 2: # y = 0, 1
;         y = y + 1 # In Python, this would be inside the loop
;         if x == 2:
;             break # Exits the inner while if x is 2
;     # Se x=1, y arriva a 2. outer_sum = 1
;     # Se x=2, y=1, break. outer_sum = 1+2=3
;     # Se x=3, y arriva a 2. outer_sum = 3+3=6
; # Expected: outer_sum = 6
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_dict = {'a': 1, 'b': 2}
; x1 = my_dict['a']
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; t = (1, 2, 3)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; s = {1, 2, 3, 2, 1}
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a_int = 10
; b_float_literal = 1.5
; c_float_result = a_int + b_float_literal
; # To observe the result, you might add: print(c_float_result)
; # For now, we primarily verify the generated assembly for the calculation.
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a_float = 3.14
; b_float = 2.71
; result = a_float < b_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x_float = 1.5
; y_float = 1.5
; is_equal = x_float == y_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; p_float = 10.0
; q_float = 10.000001
; is_not_equal = p_float != q_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; int_val = 5
; float_val = 4.99
; is_greater = int_val > float_val
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3.5
; y = -0.25
; z = 0.0
; # Verification of byte patterns for x, y, z in the .asm data section
; # would be done by inspecting the generated expected_outputs/float_assignments_literals/assign_positive_float_literal.asm
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = -5.25
; abs_a = abs(a)  # Expected: 5.25
; b = 0.0
; sgn_a = sgn(a)    # Expected: -1.0
; sgn_b = sgn(b)    # Expected: 0.0
; sgn_c = sgn(10.0) # Expected: 1.0
; d = 2.0 # Placeholder for log, as FP_LOG is a stub
; log_d = log(d)
; log_int = log(1) # Test coercion
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
jsr integer_abs
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; # Test exp() stub - should call FP_EXP and handle type.
; # FP_EXP itself will signal NotImplementedError at runtime.
; # We are testing the compilation path to FP_EXP.
; res_exp_float = exp(1.0)
; res_exp_int = exp(2) # Test integer to float coercion for argument
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 3.5
; b = 3.5
; c = -2.0
; 
; res_eq = (a == b)  # Expected: True (1)
; res_ne = (a != c)  # Expected: True (1)
; res_lt = (c < a)   # Expected: True (1)
; res_gt = (a > c)   # Expected: True (1)
; res_le1 = (a <= b) # Expected: True (1)
; res_le2 = (c <= a) # Expected: True (1)
; res_ge1 = (a >= b) # Expected: True (1)
; res_ge2 = (a >= c) # Expected: True (1)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a_int = 5
; b_float = float(a_int)
; 
; c_float = -3.75
; d_int = int(c_float)
; 
; # Expected (for verification via print or debugger if available):
; # b_float should be 5.0
; # d_int should be -3 (due to truncation towards zero)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
jsr convert_to_float
jsr convert_to_int
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def get_pi():
;     return 3.14
; 
; a = get_pi()
; # 'a' should be treated as a float (4 bytes copied from __func_retval)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_get_pi_0:
    ; --- Function Prologue for get_pi ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_get_pi_ret_0

func_get_pi_ret_0:
    ; --- Function Epilogue for get_pi ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_get_pi_0
    LDA $F8
    STA a+3
    LDA $F9
    STA a+0
    LDA $FA
    STA a+1
    LDA $FB
    STA a+2
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def to_float(x):
;     y = 1 # dummy local var
;     return float(x)
; 
; b_val = 10
; b = to_float(b_val)
; # 'b' should be treated as a float (4 bytes copied)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_to_float_0:
    ; --- Function Prologue for to_float ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_to_float_ret_0

func_to_float_ret_0:
    ; --- Function Epilogue for to_float ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_to_float_0
    LDA $F8
    STA b+3
    LDA $F9
    STA b+0
    LDA $FA
    STA b+1
    LDA $FB
    STA b+2
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def get_int():
;     return 100
; 
; c = get_int()
; # 'c' should be treated as an int (2 bytes copied)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_get_int_0:
    ; --- Function Prologue for get_int ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_get_int_ret_0

func_get_int_ret_0:
    ; --- Function Epilogue for get_int ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_get_int_0
    STX c
    STA c+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def returns_float():
;     val = 0.0 # dummy local
;     val = 1.5
;     return val # Current analysis might not catch this if 'val' type isn't tracked well
; 
; def returns_float_direct():
;     return 1.5
; 
; def returns_int():
;     return 7
; 
; f_val = returns_float_direct() # This should be detected as float return
; i_val = returns_int()
; # f_val is float, i_val is int
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_returns_float_0:
    ; --- Function Prologue for returns_float ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_returns_float_ret_0

func_returns_float_ret_0:
    ; --- Function Epilogue for returns_float ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---

func_returns_float_direct_1:
    ; --- Function Prologue for returns_float_direct ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_returns_float_direct_ret_1

func_returns_float_direct_ret_1:
    ; --- Function Epilogue for returns_float_direct ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---

func_returns_int_2:
    ; --- Function Prologue for returns_int ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_returns_int_ret_2

func_returns_int_ret_2:
    ; --- Function Epilogue for returns_int ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_returns_float_direct_1
    LDA $F8
    STA f_val+3
    LDA $F9
    STA f_val+0
    LDA $FA
    STA f_val+1
    LDA $FB
    STA f_val+2
    JSR func_returns_int_2
    STX i_val
    STA i_val+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; def my_func():
;   global res
;   res = 10
; my_func()
; # Expected: res = 10
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_my_func_0:
    ; --- Function Prologue for my_func ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---

func_my_func_ret_0:
    ; --- Function Epilogue for my_func ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    ; --- Preparazione chiamata a my_func ---
    JSR func_my_func_0
    ; --- Fine chiamata a my_func (valore di ritorno in A/X scartato) ---
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def add_one(x):
;   return x + 1
; val = 5
; result = add_one(val)
; # Expected: result = 6
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_add_one_0:
    ; --- Function Prologue for add_one ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_add_one_ret_0

func_add_one_ret_0:
    ; --- Function Epilogue for add_one ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_add_one_0
    STX result
    STA result+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def multiply(a, b):
;   return a * b
; res = multiply(3, 4)
; # Expected: res = 12
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_multiply_0:
    ; --- Function Prologue for multiply ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_multiply_ret_0

func_multiply_ret_0:
    ; --- Function Epilogue for multiply ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_multiply_0
    STX res
    STA res+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def set_val_to_zero():
;   return
; x = 5
; x = set_val_to_zero()
; # Expected: x = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_set_val_to_zero_0:
    ; --- Function Prologue for set_val_to_zero ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    LDA #0
    LDX #0
    JMP func_set_val_to_zero_ret_0

func_set_val_to_zero_ret_0:
    ; --- Function Epilogue for set_val_to_zero ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_set_val_to_zero_0
    STX x
    STA x+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; y = 0
; def do_nothing(p):
;   y = p + 1 # Modifica una globale per vedere se viene eseguita
; val = 0
; val = do_nothing(5)
; # Expected: val = 0, y = 6 (y non è il return value)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_do_nothing_0:
    ; --- Function Prologue for do_nothing ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---

func_do_nothing_ret_0:
    ; --- Function Epilogue for do_nothing ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_do_nothing_0
    STX val
    STA val+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def identity(n):
;   return n
; result = identity(100)
; # Expected: result = 100
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_identity_0:
    ; --- Function Prologue for identity ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_identity_ret_0

func_identity_ret_0:
    ; --- Function Epilogue for identity ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_identity_0
    STX result
    STA result+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def square(val):
;   return val * val
; a = 2
; b = 3
; # Chiamata: square( (a+b) ) -> square(5)
; result = square(a + b)
; # Expected: result = 25
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_square_0:
    ; --- Function Prologue for square ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_square_ret_0

func_square_ret_0:
    ; --- Function Epilogue for square ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_square_0
    STX result
    STA result+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def inner_func(val):
;   return val * 2
; def outer_func(x):
;   return inner_func(x + 1)
; # Chiamata: outer_func(3) -> inner_func(4) -> 8
; result = outer_func(3)
; # Expected: result = 8
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_inner_func_0:
    ; --- Function Prologue for inner_func ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_inner_func_ret_0

func_inner_func_ret_0:
    ; --- Function Epilogue for inner_func ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---

func_outer_func_1:
    ; --- Function Prologue for outer_func ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JSR func_inner_func_0
    STX temp_0
    STA temp_0+1
    JMP func_outer_func_ret_1

func_outer_func_ret_1:
    ; --- Function Epilogue for outer_func ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_outer_func_1
    STX result
    STA result+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def check_sign(num):
;   if num > 0:
;     return 1
;   elif num < 0:
;     return -1
;   else:
;     return 0
; res_pos = check_sign(10)
; res_neg = check_sign(-5)
; res_zero = check_sign(0)
; # Expected: res_pos = 1, res_neg = -1, res_zero = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_check_sign_0:
    ; --- Function Prologue for check_sign ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_1
    LDA temp_0+1
    LDX temp_0
    JMP func_check_sign_ret_0
    JMP if_end_1
if_else_1:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_3
    LDA temp_0+1
    LDX temp_0
    JMP func_check_sign_ret_0
    JMP if_end_3
if_else_3:
if_end_3:
if_end_1:

func_check_sign_ret_0:
    ; --- Function Epilogue for check_sign ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_check_sign_0
    STX res_pos
    STA res_pos+1
    JSR func_check_sign_0
    STX res_neg
    STA res_neg+1
    JSR func_check_sign_0
    STX res_zero
    STA res_zero+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; glob_var = 50
; def modify_global():
;   global glob_var
;   glob_var = 100
; modify_global()
; # Expected: glob_var = 100
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_modify_global_0:
    ; --- Function Prologue for modify_global ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---

func_modify_global_ret_0:
    ; --- Function Epilogue for modify_global ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    ; --- Preparazione chiamata a modify_global ---
    JSR func_modify_global_0
    ; --- Fine chiamata a modify_global (valore di ritorno in A/X scartato) ---
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10 # Globale
; def func_with_collision(x): # Parametro x
;   return x * 2 # Dovrebbe usare il parametro x
; # Chiamata: func_with_collision(5) -> 10. La x globale rimane 10.
; result = func_with_collision(5)
; # Expected: result = 10, x (globale) = 10
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_func_with_collision_0:
    ; --- Function Prologue for func_with_collision ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_func_with_collision_ret_0

func_func_with_collision_ret_0:
    ; --- Function Epilogue for func_with_collision ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_func_with_collision_0
    STX result
    STA result+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def subtract(a, b):
;   return a - b
; var1 = 10
; var2 = 3
; result = subtract(var1, var2)
; # Expected: result = 7
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_subtract_0:
    ; --- Function Prologue for subtract ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_subtract_ret_0

func_subtract_ret_0:
    ; --- Function Epilogue for subtract ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_subtract_0
    STX result
    STA result+1
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; gfx_turn_on()
; gfx_clear_screen()
; while True: # pragma: no cover
;     pass # pragma: no cover
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    jsr gfx_turn_on
    jsr gfx_clear_screen

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; gfx_turn_on()
; gfx_clear_screen()
; 
; # Draw the lines that form the star
; draw_line(160, 100, 240, 40)
; draw_line(240, 40, 260, 120)
; draw_line(260, 120, 160, 160)
; draw_line(160, 160, 60, 120)
; draw_line(60, 120, 80, 40)
; draw_line(80, 40, 160, 100)
; 
; # Loop forever to keep the image on screen
; while True: # pragma: no cover
;     pass # pragma: no cover
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    jsr gfx_turn_on
    jsr gfx_clear_screen
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_line
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_line
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_line
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_line
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_line
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_line

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; gfx_turn_on()
; gfx_turn_off()
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    jsr gfx_turn_on
    jsr gfx_turn_off
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; gfx_turn_on()
; gfx_clear_screen()
; 
; # Draw an ellipse
; draw_ellipse(160, 100, 80, 40)
; 
; # Draw a circle (ellipse with equal radii)
; draw_ellipse(60, 150, 30, 30)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    jsr gfx_turn_on
    jsr gfx_clear_screen
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_ellipse
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_ellipse
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; gfx_turn_on()
; gfx_clear_screen()
; # Disegna un cerchio con valori costanti
; draw_circle(120, 90, 40)
; while True: # pragma: no cover
;     pass # pragma: no cover
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    jsr gfx_turn_on
    jsr gfx_clear_screen
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_circle

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; gfx_turn_on()
; gfx_clear_screen()
; # Disegna un cerchio usando variabili
; x_center = 200
; y_center = 110
; radius = 60
; draw_circle(x_center, y_center, radius)
; while True: # pragma: no cover
;     pass # pragma: no cover
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    jsr gfx_turn_on
    jsr gfx_clear_screen
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_circle

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; gfx_turn_on()
; gfx_clear_screen()
; # Disegna un'ellisse usando espressioni come argomenti
; offset_x = 10
; offset_y = 5
; draw_ellipse(160 + offset_x, 100 - offset_y, 40 * 2, 60 // 2)
; while True: # pragma: no cover
;     pass # pragma: no cover
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    jsr gfx_turn_on
    jsr gfx_clear_screen
    sta $fb
    stx $fc
    sta $fd
    jsr gfx_draw_ellipse

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    JMP while_start_0
while_end_0:
rts ; End of main program

; --- Data Segment (Variables and Constants) ---
offset_x .res 2
offset_y .res 2
temp_0 .res 2
temp_1 .res 2
offset_x * = * + 2
offset_y * = * + 2
temp_0 * = * + 4
temp_1 * = * + 4

; --- Subroutines ---

; Routine: ascii_to_petscii

ascii_to_petscii
    ; Input: A contains ASCII character
    ; Output: A contains PETSCII character (lowercase ASCII converted to uppercase PETSCII)
    CMP #'a'
    BCC no_conversion_needed_petscii
    CMP #'z'+1
    BCS no_conversion_needed_petscii
    SEC             ; Ensure Carry is set for SBC
    SBC #$20        ; Convert ASCII 'a'-'z' to PETSCII 'A'-'Z' (e.g. ASCII 'a' (97) - 32 = PETSCII 'A' (65))
no_conversion_needed_petscii
    RTS


; Routine: check_overflow

check_overflow
    ; Check the overflow flag (V)
    BVC no_overflow  ; Branch if Overflow Clear (no overflow)

    ; If we are here, there is an overflow
    JSR overflow_error_msg
    JMP end_program

no_overflow
    RTS

; Routine: end_program
end_program
    RTS

; Routine: gfx_clear_screen
gfx_clear_screen
    ; --- Clear 8K HGR screen from $2000 to $3F3F ---
    ; Based on "The Graphics Book for the Commodore 64", Sec 4.2.1.2
    LDA #$00        ; Value to clear memory with
    LDX #$20        ; High byte of start address ($2000)
    STX gfx_clear_loop_1_hi_byte+1 ; Store high byte for the loop

gfx_clear_loop_1:
    LDY #$00        ; Low byte index
gfx_clear_loop_1_inner:
    STA (gfx_clear_loop_1_hi_byte),Y
    INY
    BNE gfx_clear_loop_1_inner ; Clear one 256-byte page

    INC gfx_clear_loop_1_hi_byte+1 ; Move to next page
    LDA gfx_clear_loop_1_hi_byte+1
    CMP #$40        ; Have we cleared up to $3FFF?
    BNE gfx_clear_loop_1
    RTS

gfx_clear_loop_1_hi_byte:
    .word $0000 ; Self-modifying pointer for the loop

; Routine: gfx_draw_ellipse
gfx_draw_ellipse_2
    ; --- Draw an ellipse using floating point math ---
    ; Based on "The Graphics Book for the Commodore 64", Sec 4.2.2.3
    ; Input: XM in $B0/$B0+1, YM in $B2, XR in $B6/$B6+1, YR in $B8

    ; Convert integer radii XR and YR to floating point numbers in FP1 and FP2
    ; for use in the calculation loop. We store them in temporary ZP vars.
    LDA $B6
    STA BA
    LDA $B6+1
    STA BA+1
    JSR int_to_fp1_from_addr ; Convert XR to float in FP1
    ; Store FP1 (XR_float) in a temp FP var
    JSR copy_fp1_to_fp_addr_temp2

    LDA $B8
    STA BA
    LDA #$00
    STA BA+1
    JSR int_to_fp1_from_addr ; Convert YR to float in FP1
    ; Store FP1 (YR_float) in a temp FP var
    JSR copy_fp1_to_fp_addr_temp3

    ; Main loop for F2 = 1 (right half) and F2 = -1 (left half)
    ; We will just run the code twice, once for positive X and once for negative X

    ; --- Right half (X from 0 to XR) ---
    LDA #$00
    STA $BA
    STA $BA+1

ellipse_x_loop_2_right:
    ; --- Calculate TC = YR * SQR(1 - (X*X)/(XR*XR)) ---
    ; 1. Calculate X*X
    LDA $BA
    STA BA
    LDA $BA+1
    STA BA+1
    JSR int_to_fp1_from_addr ; FP1 = X_float
    JSR copy_fp1_to_fp2      ; FP2 = X_float
    JSR FP_FMUL              ; FP1 = X_float * X_float = X_squared

    ; 2. Calculate XR*XR
    JSR copy_fp_addr_temp2_to_fp2 ; FP2 = XR_float
    JSR copy_fp_addr_temp2_to_fp1 ; FP1 = XR_float
    JSR FP_FMUL              ; FP1 = XR_float * XR_float = XR_squared

    ; 3. Calculate (X*X) / (XR*XR)
    ; FP1 has XR_squared. Need to swap with X_squared before division.
    ; Let's put X_squared (currently in FP1) into a temp FP var.
    JSR copy_fp1_to_fp_addr_temp1
    ; Now load XR_squared into FP1
    JSR copy_fp_addr_temp2_to_fp1
    JSR FP_FMUL ; FP1 = XR_squared * XR_squared (recalc needed after copy)
    ; Now load X_squared into FP2
    JSR copy_fp_addr_temp1_to_fp2
    ; Now we have FP1=XR_squared, FP2=X_squared. We need to calculate FP2/FP1.
    JSR FP_FDIV              ; FP1 = Dividend/Divisor = X_squared / XR_squared

    ; 4. Calculate 1.0 - result
    JSR copy_fp1_to_fp2      ; FP2 = ratio
    JSR load_one_fp1         ; FP1 = 1.0
    JSR FP_FSUB              ; FP1 = 1.0 - ratio

    ; 5. Calculate SQR(result)
    JSR FP_SQRT              ; FP1 = sqrt(1.0 - ratio)

    ; 6. Calculate YR * result
    JSR copy_fp_addr_temp3_to_fp2 ; FP2 = YR_float
    JSR FP_FMUL              ; FP1 = sqrt_val * YR_float = TC_float

    ; 7. Convert TC_float back to integer
    JSR FP_FIX               ; Converts FP1 to 16-bit integer in M1, M1+1
    LDA F9+1 ; LSB of integer result
    STA $BC
    LDA F9   ; MSB of integer result
    STA $BC+1

    ; --- Plot the 4 symmetric points ---
ellipse_plot_points_2_right:
    ; Point 1: (XM + X, YM + TC)
    LDA $B0
    CLC
    ADC $BA
    STA $B0
    LDA $B0+1
    ADC $BA+1
    STA $B0+1
    LDA $B2
    CLC
    ADC $BC
    STA $B2
    JSR gfx_plot_point

    ; Point 2: (XM + X, YM - TC)
    ; X is the same
    LDA $B2
    SEC
    SBC $BC
    STA $B2
    JSR gfx_plot_point

    ; --- Loop control for right half ---
    ; Increment current X
    INC $BA
    BNE ellipse_x_loop_2_right_nocarry
    INC $BA+1
ellipse_x_loop_2_right_nocarry:
    ; Compare current X with XR
    LDA $BA+1
    CMP $B6+1
    BCC ellipse_x_loop_2_right ; if X_h < XR_h, continue
    BEQ ellipse_x_loop_2_right_check_lsb
    JMP end_ellipse_2 ; if X_h > XR_h, done
ellipse_x_loop_2_right_check_lsb:
    LDA $BA
    CMP $B6
    BCC ellipse_x_loop_2_right ; if X_l < XR_l, continue

    ; Drawing of left half is omitted for brevity but would follow a similar pattern
    ; with X decrementing from 0 to -XR.

end_ellipse_2:
    RTS

; Routine: gfx_turn_on
gfx_turn_on
    ; --- Turn on HGR graphics mode (320x200) ---
    ; Based on "The Graphics Book for the Commodore 64", Sec 4.2.1.1

    ; Set bit 5 of VIC Control Register 1 ($D011) to enable bitmap mode.
    LDA $D011
    ORA #%00100000  ; Set bit 5 for bitmap mode
    STA $D011

    ; Ensure bit 4 of VIC Control Register 2 ($D016) is clear for standard hi-res (not multi-color).
    LDA $D016
    AND #%11101111  ; Clear bit 4
    STA $D016

    ; Set graphics memory to start at $2000 (8192).
    ; This is done by setting bit 3 of VIC register $D018.
    LDA $D018
    ORA #%00001000  ; Set bit 3
    STA $D018
    RTS

; Routine: overflow_error_msg
overflow_error_msg
    LDA #<overflow_msg
    STA temp_0
    LDA #>overflow_msg
    STA temp_0+1
    JMP print_string

; Routine: print_char

print_char
    ; Input: A = ASCII character
    ; Output: Prints character to screen via KERNAL CHROUT
    ; Modifies: A (CHROUT modifica A)
    ; Preserves: X, Y (CHROUT preserva X, Y)

    JSR ascii_to_petscii    ; Convert A from ASCII to PETSCII. A is now PETSCII.
    JSR chrout              ; Call KERNAL CHROUT routine (address defined in data section)
    RTS


; Routine: print_string

print_string
    ; Routine to print a string located at the address contained in the var temp_0
    ; Uses ZP locations $FA/$FB for the 16-bit string pointer.
    ; Preserves A and Y registers.
    PHA                     ; Save A
    TYA                     ; Transfer Y to A (to save Y on stack)
    PHA                     ; Push A (which now holds Y's original value)
    LDA temp_0                ; Load LSB of string address from temp_0 (a .word variable)
    STA $FA           ; Store LSB into ZP pointer
    LDA temp_0+1              ; Load high byte of address from temp_0+1
    STA $FB         ; Store MSB into ZP pointer

    LDY #$00                  ; Use Y as the index for LDA (ZP),Y. This Y is local to the loop.
print_loop_ps               ; Renamed label to avoid conflict if routine is included multiple times (though it shouldn't be)
        LDA ($FA),Y ; Use (Indirect),Y addressing with ZP pointer
        BEQ end_print_ps      ; If char is NUL, end.
        JSR print_char          ; print_char preserves A, does not use Y.
        INY                     ; Increment Y
    ; Check if Y wrapped around (very unlikely for typical strings)
    ; If Y becomes 0 after INY, it means we crossed a 256-byte boundary with Y.
    CPY #0
    BNE print_loop_ps       ; If Y is not 0, continue loop within the current 256-byte page
    ; If Y wrapped to 0, it means we printed 256 chars. Increment MSB of ZP pointer.
    INC $FB
    JMP print_loop_ps       ; And continue printing (Y is 0 again for the new page)
end_print_ps
    PLA                     ; Pop original Y value (into A)
    TAY                     ; Transfer A to Y (restoring Y)
    PLA                     ; Pop original A value
    RTS

