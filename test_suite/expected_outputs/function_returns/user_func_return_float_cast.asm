; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 10
; x2 = 20
; z = x1 + x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a1 = 5
; b = 3
; c = a1 * b + (a1 - b) // 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 250
; x2 = 10
; z = x1 + x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 10
; x2 = 0
; z = x1 // x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 10 # 00001010
; b = 5  # 00000101
; c = a ^ b # Expected result: 15 (00001111)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; val1 = 255 # 11111111 00000000
; val2 = 85  # 01010101 00000000
; # 255 (00FF) ^ 85 (0055) = 170 (00AA)
; res_xor = val1 ^ val2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 2 * 5
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; y = 10 // 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; z = 5 + 3.14
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3]
; for item in my_list:
;   x = item * 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; while i < 5:
;   i = i + 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; res = 0
; if x == 10:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; res = 0
; if x == 10:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; res = 0
; if x > 5:
;   res = 1
; else:
;   res = 2
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; res = 0
; if x > 5:
;   res = 1
; else:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 15
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_2
    JMP if_end_2
if_else_2:
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 7
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_2
    JMP if_end_2
if_else_2:
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 3
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_2
    JMP if_end_2
if_else_2:
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 12
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_2
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 8
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_2
if_end_2:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 5
; res = 0
; if x <= y:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 5
; res = 0
; if x < y:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; y = 5
; res = 0
; if x > 5:
;   if y < 10:
;     res = 1
;   else:
;     res = 2
; else:
;   res = 3
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_2
    JMP if_end_2
if_else_2:
if_end_2:
    JMP if_end_0
if_else_0:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if True:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if False:
;   res = 1
; else:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_else_0
    JMP if_end_0
if_else_0:
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 10
; res = 0
; if x + 2 > y - 5:
;   res = 1
; # Expected: 7 > 5 -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; y = 1
; res = 0
; if x * 2 == y + 5:
;   res = 1
; # Expected: 6 == 6 -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; res = 0
; if not x:
;   res = 1
; # Expected: not 0 -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; res = 0
; if not x:
;   res = 1
; # Expected: not 5 -> False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 10
; res = 0
; if x > 0 and y > 0:
;   res = 1
; # Expected: True and True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if x > 0 and y > 0:
;   res = 1
; # Expected: True and False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 10
; res = 0
; if x > 0 and y > 0: # y > 0 should not be evaluated if the compiler is smart
;   res = 1
; # Expected: False and True -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if x > 0 or y > 0: # y > 0 should not be evaluated
;   res = 1
; # Expected: True or False -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 10
; res = 0
; if x > 0 or y > 0:
;   res = 1
; # Expected: False or True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 0
; res = 0
; if x > 0 or y > 0:
;   res = 1
; # Expected: False or False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if not (x == 0 and y == 0):
;   res = 1
; # Expected: not (False and True) -> not False -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 0
; res = 0
; if not (x > 0 or y > 0):
;   res = 1
; # Expected: not (False or False) -> not False -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if True and False:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 10
; b = 5
; res = 0
; if (a ^ b): # 10^5 = 15 (non-zero, quindi True)
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 7
; b = 7
; res = 0
; if (a ^ b): # 7^7 = 0 (zero, quindi False)
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_0
if_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; res = 0
; while i < 10:
;   res = res + i
;   i = i + 1
;   if i == 5:
;     break
; # Expected: res = 0+1+2+3+4 = 10, i = 5
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_2
if_end_2:
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; res = 0
; while i < 5:
;   i = i + 1
;   if i == 3:
;     continue
;   res = res + i
; # Expected: i=5, res = 1+2+4+5 = 12
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

while_start_0:
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ while_end_0
    LDA temp_0+1
    LDX temp_0
    ORA X
    BEQ if_end_2
if_end_2:
    JMP while_start_0
while_end_0:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3, 4, 5]
; res = 0
; for item in my_list:
;   if item == 4:
;     break
;   res = res + item
; # Expected: res = 1+2+3 = 6
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3, 4, 5]
; res = 0
; for item in my_list:
;   if item == 3:
;     continue
;   res = res + item
; # Expected: res = 1+2+4+5 = 12
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; outer_sum = 0
; my_list = [1, 2, 3]
; for x in my_list: # x = 1, 2, 3
;     outer_sum = outer_sum + x
;     y = 0
;     while y < 2: # y = 0, 1
;         y = y + 1 # In Python, this would be inside the loop
;         if x == 2:
;             break # Exits the inner while if x is 2
;     # Se x=1, y arriva a 2. outer_sum = 1
;     # Se x=2, y=1, break. outer_sum = 1+2=3
;     # Se x=3, y arriva a 2. outer_sum = 3+3=6
; # Expected: outer_sum = 6
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_dict = {}
; my_dict['c'] = 3
; del my_dict['d']
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_dict = {'a': 1, 'b': 2}
; x1 = my_dict['a']
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; t = (1, 2, 3)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; s = {1, 2, 3, 2, 1}
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a_int = 10
; b_float_literal = 1.5
; c_float_result = a_int + b_float_literal
; # To observe the result, you might add: print(c_float_result)
; # For now, we primarily verify the generated assembly for the calculation.
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a_float = 3.14
; b_float = 2.71
; result = a_float < b_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x_float = 1.5
; y_float = 1.5
; is_equal = x_float == y_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; p_float = 10.0
; q_float = 10.000001
; is_not_equal = p_float != q_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; int_val = 5
; float_val = 4.99
; is_greater = int_val > float_val
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3.5
; y = -0.25
; z = 0.0
; # Verification of byte patterns for x, y, z in the .asm data section
; # would be done by inspecting the generated expected_outputs/float_assignments_literals/assign_positive_float_literal.asm
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = -5.25
; abs_a = abs(a)  # Expected: 5.25
; b = 0.0
; sgn_a = sgn(a)    # Expected: -1.0
; sgn_b = sgn(b)    # Expected: 0.0
; sgn_c = sgn(10.0) # Expected: 1.0
; d = 2.0 # Placeholder for log, as FP_LOG is a stub
; log_d = log(d)
; log_int = log(1) # Test coercion
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
jsr integer_abs
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; # Test exp() stub - should call FP_EXP and handle type.
; # FP_EXP itself will signal NotImplementedError at runtime.
; # We are testing the compilation path to FP_EXP.
; res_exp_float = exp(1.0)
; res_exp_int = exp(2) # Test integer to float coercion for argument
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 3.5
; b = 3.5
; c = -2.0
; 
; res_eq = (a == b)  # Expected: True (1)
; res_ne = (a != c)  # Expected: True (1)
; res_lt = (c < a)   # Expected: True (1)
; res_gt = (a > c)   # Expected: True (1)
; res_le1 = (a <= b) # Expected: True (1)
; res_le2 = (c <= a) # Expected: True (1)
; res_ge1 = (a >= b) # Expected: True (1)
; res_ge2 = (a >= c) # Expected: True (1)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a_int = 5
; b_float = float(a_int)
; 
; c_float = -3.75
; d_int = int(c_float)
; 
; # Expected (for verification via print or debugger if available):
; # b_float should be 5.0
; # d_int should be -3 (due to truncation towards zero)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
jsr convert_to_float
jsr convert_to_int
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def get_pi():
;     return 3.14
; 
; a = get_pi()
; # 'a' should be treated as a float (4 bytes copied from __func_retval)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_get_pi_0:
    ; --- Function Prologue for get_pi ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_get_pi_ret_0

func_get_pi_ret_0:
    ; --- Function Epilogue for get_pi ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_get_pi_0
    LDA $F8
    STA a+3
    LDA $F9
    STA a+0
    LDA $FA
    STA a+1
    LDA $FB
    STA a+2
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; def to_float(x):
;     y = 1 # dummy local var
;     return float(x)
; 
; b_val = 10
; b = to_float(b_val)
; # 'b' should be treated as a float (4 bytes copied)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:

func_to_float_0:
    ; --- Function Prologue for to_float ---
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR push_word_from_addr
    LDA $E0
    STA $E2
    LDA $E1
    STA $E3
    ; --- End Function Prologue ---
    JMP func_to_float_ret_0

func_to_float_ret_0:
    ; --- Function Epilogue for to_float ---
    LDA $E2
    STA $E0
    LDA $E3
    STA $E1
    LDA #<00E2
    STA $F2
    LDA #>00E2
    STA $F3
    JSR pop_word_to_addr
    RTS
    ; --- End Function Epilogue ---
    JSR func_to_float_0
    LDA $F8
    STA b+3
    LDA $F9
    STA b+0
    LDA $FA
    STA b+1
    LDA $FB
    STA b+2
rts ; End of main program

; --- Data Segment (Variables and Constants) ---
__func_arg_0 .res 2
b .res 4
b_val .res 2
temp_0 .res 4
temp_1 .res 4
__func_arg_0 * = * + 2
__to_float_y * = * + 2
b * = * + 4
b_val * = * + 2
temp_0 * = * + 4
temp_1 * = * + 4

; --- Subroutines ---

; Routine: FP_FLOAT
FP_FLOAT     ; Original F451 - Converts 16-bit int in M1, M1+1 to FP in X1,M1. M1+2 must be 0.
    LDA  #$8E     ; INIT EXP1 TO 14 ($80 + 14 = $8E),
    STA  $F8       ; THEN NORMALIZE TO FLOAT.
    JMP FP_NORM1  ; Jump to the NORM1 section for normalization

; Routine: FP_NORM
FP_NORM      ; Original F463
FP_NORM_CHECK_X1
    LDA  $F8       ; EXP1 ZERO?
    BNE  FP_NORM1    ; NO, CONTINUE NORMALIZING.
    ; X1 is zero. If M1 is also zero, it's a true zero. Otherwise, it's smallest denormalized.
    LDA $F9
    ORA $FA
    ORA $FB
    BNE FP_RTS1_NORM_EXIT ; If mantissa not zero, exit (it's 0 * 2^-128 or similar)
    ; True zero, X1 already 0. Mantissa is 0.
FP_RTS1_NORM_EXIT
    RTS           ; RETURN.

; Routine: FP_NORM1
FP_NORM1     ; Original F455
    LDA  $F9       ; HIGH-ORDER MANT1 BYTE.
    CMP  #$C0     ; UPPER TWO BITS UNEQUAL? (01xxxxxx or 10xxxxxx)
    BMI  FP_RTS1_NORM     ; YES, RETURN WITH MANT1 NORMALIZED
    ; Not normalized or zero
    DEC  $F8       ; DECREMENT EXP1.
    ASL  $FB
    ROL  $FA     ; SHIFT MANT1 (3 BYTES) LEFT.
    ROL  $F9
    ; Fall through to NORM's check
    JMP FP_NORM_CHECK_X1
FP_RTS1_NORM RTS
