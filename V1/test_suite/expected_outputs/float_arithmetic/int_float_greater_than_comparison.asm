; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 10
; x2 = 20
; z = x1 + x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a1 = 5
; b = 3
; c = a1 * b + (a1 - b) // 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 250
; x2 = 10
; z = x1 + x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x1 = 10
; x2 = 0
; z = x1 // x2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 10 # 00001010
; b = 5  # 00000101
; c = a ^ b # Expected result: 15 (00001111)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; val1 = 255 # 11111111 00000000
; val2 = 85  # 01010101 00000000
; # 255 (00FF) ^ 85 (0055) = 170 (00AA)
; res_xor = val1 ^ val2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 2 * 5
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; y = 10 // 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; z = 5 + 3.14
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3]
; for item in my_list:
;   x = item * 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; while i < 5:
;   i = i + 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; res = 0
; if x == 10:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; res = 0
; if x == 10:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; res = 0
; if x > 5:
;   res = 1
; else:
;   res = 2
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; res = 0
; if x > 5:
;   res = 1
; else:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 15
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 7
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; else:
;   res = 3
; # Expected: res = 3
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 12
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 8
; res = 0
; if x > 10:
;   res = 1
; elif x > 5:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 5
; res = 0
; if x <= y:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 5
; res = 0
; if x < y:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 10
; y = 5
; res = 0
; if x > 5:
;   if y < 10:
;     res = 1
;   else:
;     res = 2
; else:
;   res = 3
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if True:
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if False:
;   res = 1
; else:
;   res = 2
; # Expected: res = 2
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 10
; res = 0
; if x + 2 > y - 5:
;   res = 1
; # Expected: 7 > 5 -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 3
; y = 1
; res = 0
; if x * 2 == y + 5:
;   res = 1
; # Expected: 6 == 6 -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; res = 0
; if not x:
;   res = 1
; # Expected: not 0 -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; res = 0
; if not x:
;   res = 1
; # Expected: not 5 -> False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 10
; res = 0
; if x > 0 and y > 0:
;   res = 1
; # Expected: True and True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if x > 0 and y > 0:
;   res = 1
; # Expected: True and False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 10
; res = 0
; if x > 0 and y > 0: # y > 0 should not be evaluated if the compiler is smart
;   res = 1
; # Expected: False and True -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if x > 0 or y > 0: # y > 0 should not be evaluated
;   res = 1
; # Expected: True or False -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 10
; res = 0
; if x > 0 or y > 0:
;   res = 1
; # Expected: False or True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 0
; res = 0
; if x > 0 or y > 0:
;   res = 1
; # Expected: False or False -> res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 5
; y = 0
; res = 0
; if not (x == 0 and y == 0):
;   res = 1
; # Expected: not (False and True) -> not False -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; x = 0
; y = 0
; res = 0
; if not (x > 0 or y > 0):
;   res = 1
; # Expected: not (False or False) -> not False -> True -> res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; res = 0
; if True and False:
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 10
; b = 5
; res = 0
; if (a ^ b): # 10^5 = 15 (non-zero, quindi True)
;   res = 1
; # Expected: res = 1
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a = 7
; b = 7
; res = 0
; if (a ^ b): # 7^7 = 0 (zero, quindi False)
;   res = 1
; # Expected: res = 0
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; res = 0
; while i < 10:
;   res = res + i
;   i = i + 1
;   if i == 5:
;     break
; # Expected: res = 0+1+2+3+4 = 10, i = 5
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; i = 0
; res = 0
; while i < 5:
;   i = i + 1
;   if i == 3:
;     continue
;   res = res + i
; # Expected: i=5, res = 1+2+4+5 = 12
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3, 4, 5]
; res = 0
; for item in my_list:
;   if item == 4:
;     break
;   res = res + item
; # Expected: res = 1+2+3 = 6
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_list = [1, 2, 3, 4, 5]
; res = 0
; for item in my_list:
;   if item == 3:
;     continue
;   res = res + item
; # Expected: res = 1+2+4+5 = 12
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; outer_sum = 0
; my_list = [1, 2, 3]
; for x in my_list: # x = 1, 2, 3
;     outer_sum = outer_sum + x
;     y = 0
;     while y < 2: # y = 0, 1
;         y = y + 1 # In Python, this would be inside the loop
;         if x == 2:
;             break # Exits the inner while if x is 2
;     # Se x=1, y arriva a 2. outer_sum = 1
;     # Se x=2, y=1, break. outer_sum = 1+2=3
;     # Se x=3, y arriva a 2. outer_sum = 3+3=6
; # Expected: outer_sum = 6
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_dict = {}
; my_dict['c'] = 3
; del my_dict['d']
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; my_dict = {'a': 1, 'b': 2}
; x1 = my_dict['a']
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; t = (1, 2, 3)
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; s = {1, 2, 3, 2, 1}
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a_int = 10
; b_float_literal = 1.5
; c_float_result = a_int + b_float_literal
; # To observe the result, you might add: print(c_float_result)
; # For now, we primarily verify the generated assembly for the calculation.
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; a_float = 3.14
; b_float = 2.71
; result = a_float < b_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; x_float = 1.5
; y_float = 1.5
; is_equal = x_float == y_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; p_float = 10.0
; q_float = 10.000001
; is_not_equal = p_float != q_float
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program
; Generated by py2c64 compiler
; --- Python Source Code ---
; int_val = 5
; float_val = 4.99
; is_greater = int_val > float_val
; --------------------------
* = $1000
; --- Main Program and Functions ---
main:
rts ; End of main program

; --- Data Segment (Variables and Constants) ---
float_val .res 4
int_val .res 2
is_greater .res 2
temp_0 .res 4
float_val * = * + 2
int_val * = * + 2
temp_0 * = * + 4

; --- Subroutines ---

; Routine: FP_ADD_MANT
FP_ADD_MANT  ; Original F425
    CLC           ; CLEAR CARRY
    LDX  #$2      ; INDEX FOR 3-BYTE ADD.
FP_ADD1_MANT      LDA  $F9,X
    ADC  $F5,X     ; ADD A BYTE OF MANT2 TO MANT1
    STA  $F9,X
    DEX           ; INDEX TO NEXT MORE SIGNIF. BYTE.
    BPL  FP_ADD1_MANT     ; LOOP UNTIL DONE.
    RTS           ; RETURN

; Routine: FP_ALGNSWP
FP_ALGNSWP   ; Original F47B - Called when X1 != X2. Carry from CMP X1 is key.
             ; CMP X2, X1. If C=0 (X2 < X1), then swap.
    BCC  FP_ALGNSWP_SWAP     ; SWAP IF CARRY CLEAR (X2 < X1)
    ; Here X2 >= X1. Shift M1 (smaller magnitude) right.
FP_ALGNSWP_SHIFT_M1:
    JSR  FP_RTAR      ; Shifts M1 right, increments X1.
    LDA  $F4   ; Compare X2 with new X1
    CMP  $F8
    BNE  FP_ALGNSWP_SHIFT_M1 ; Loop if still not equal
    RTS              ; Exponents equal, return to FADD to add mantissas
FP_ALGNSWP_SWAP:
    JSR  FP_SWAP      ; Swap FP1 and FP2
    ; After swap, X1 was original X2, X2 was original X1.
    ; Now X1 (new) > X2 (new). Shift M2 (which is now in M1 due to prior logic flow)
    JMP FP_ALGNSWP_SHIFT_M1 ; Re-enter logic to shift the (now smaller) M1.

; Routine: FP_FADD
FP_FADD      ; Original F46E
    LDA  $F4
    CMP  $F8       ; COMPARE EXP1 WITH EXP2.
    BNE  FP_FADD_SWPALGN  ; IF #,SWAP ADDENDS OR ALIGN MANTS.
FP_FADD_ADD_ALIGNED
    JSR  FP_ADD_MANT      ; ADD ALIGNED MANTISSAS.
FP_FADD_ADDEND ; Original F477
    BVC  FP_NORM     ; NO OVERFLOW, NORMALIZE RESULT.
    ; Overflow occurred during mantissa add
    BVS  FP_RTLOG_ENTRY    ; OV: SHIFT M1 RIGHT, CARRY (sign of sum) INTO SIGN
    RTS ; Should not be reached
FP_FADD_SWPALGN ; Original F46B (SWPALGN label) / F472 (BNE target)
    JSR FP_ALGNSWP
    JMP FP_FADD_ADD_ALIGNED ; After alignment, add mantissas

; Routine: FP_FCOMPL
FP_FCOMPL    ; Original F4A4
    SEC           ; SET CARRY FOR SUBTRACT.
    LDX  #$02     ; INDEX FOR 3 BYTE SUBTRACT (M1, M1+1, M1+2)
FP_FCOMPL_COMPL1 LDA  #$00     ; CLEAR A.
    SBC  $F9,X     ; SUBTRACT BYTE OF M1 (0 - M1,X - C)
    STA  $F9,X     ; RESTORE IT.
    DEX
    BPL  FP_FCOMPL_COMPL1   ; LOOP UNTIL DONE.
    CLC           ; Clear carry after 2's complement.
    BEQ  FP_FADD_ADDEND ; NORMALIZE (OR SHIFT RT IF OVFL). (Jumps to FADD's overflow handling/normalization path)
    RTS ; Should not be reached if BEQ taken

; Routine: FP_FLOAT
FP_FLOAT     ; Original F451 - Converts 16-bit int in M1, M1+1 to FP in X1,M1. M1+2 must be 0.
    LDA  #$8E     ; INIT EXP1 TO 14 ($80 + 14 = $8E),
    STA  $F8       ; THEN NORMALIZE TO FLOAT.
    JMP FP_NORM1  ; Jump to the NORM1 section for normalization

; Routine: FP_FSUB
FP_FSUB      ; Original F468. Calculates FP1 = FP1 - FP2.
             ; FP1 is in X1/M1, FP2 is in X2/M2. Result in X1/M1.
    JSR FP_SWAP      ; M1 now holds original FP2, M2 now holds original FP1.
                     ; E gets original FP2 mantissa (not strictly needed for FSUB logic but SWAP does it).
    JSR FP_FCOMPL    ; M1 (which was original FP2) is complemented: M1 = -original_FP2.
                     ; M2 is still original FP1.
    JMP FP_FADD      ; Calculates M1_current + M2_current = (-original_FP2) + original_FP1.
                     ; Result (original_FP1 - original_FP2) is stored in X1/M1.

; Routine: FP_NORM
FP_NORM      ; Original F463
FP_NORM_CHECK_X1
    LDA  $F8       ; EXP1 ZERO?
    BNE  FP_NORM1    ; NO, CONTINUE NORMALIZING.
    ; X1 is zero. If M1 is also zero, it's a true zero. Otherwise, it's smallest denormalized.
    LDA $F9
    ORA $FA
    ORA $FB
    BNE FP_RTS1_NORM_EXIT ; If mantissa not zero, exit (it's 0 * 2^-128 or similar)
    ; True zero, X1 already 0. Mantissa is 0.
FP_RTS1_NORM_EXIT
    RTS           ; RETURN.

; Routine: FP_NORM1
FP_NORM1     ; Original F455
    LDA  $F9       ; HIGH-ORDER MANT1 BYTE.
    CMP  #$C0     ; UPPER TWO BITS UNEQUAL? (01xxxxxx or 10xxxxxx)
    BMI  FP_RTS1_NORM     ; YES, RETURN WITH MANT1 NORMALIZED
    ; Not normalized or zero
    DEC  $F8       ; DECREMENT EXP1.
    ASL  $FB
    ROL  $FA     ; SHIFT MANT1 (3 BYTES) LEFT.
    ROL  $F9
    ; Fall through to NORM's check
    JMP FP_NORM_CHECK_X1
FP_RTS1_NORM RTS

; Routine: FP_OVFL_HANDLER
FP_OVFL_HANDLER
    LDA #1
    JMP error_handler ; Use the project's main error handler

; Routine: FP_RTAR
FP_RTAR      ; Original F47D
    LDA  $F9       ; SIGN OF MANT1 INTO CARRY FOR
    ASL           ; RIGHT ARITH SHIFT. (Sign bit to Carry, 0 into bit 7)
    ; Fall through to RTLOG
    JMP FP_RTLOG_COMMON_PART ; Jump to the part of RTLOG that does the work

; Routine: FP_RTLOG
FP_RTLOG_COMMON_PART: ; Label for common logic of RTLOG and RTAR
    INC  $F8       ; INCR X1 TO ADJUST FOR RIGHT SHIFT
    BEQ  FP_OVFL_ROUTINE_CALL     ; EXP1 OUT OF RANGE.
    ; Fall through to RTLOG1
    JMP FP_RTLOG1

; Routine: FP_RTLOG1
FP_RTLOG1    ; Original F484 - Shifts M1 and E right 1 bit. Carry from input shifts into M1 MSB.
    LDX  #$FA     ; INDEX FOR 6-BYTE RIGHT SHIFT (M1_H, M1_M, M1_L, E_H, E_M, E_L)
                  ; $FA = -6. E+3,X means base $FF+X.
                  ; $FF-6 = $F9 (M1_H)
                  ; $FF-5 = $FA (M1_M)
                  ; ...
                  ; $FF-1 = $FE (E_L)
FP_RTLOG1_ROR1
    ROR  $FF,X ; ROR ($FF),X then ($00),X etc.
    INX           ; NEXT BYTE OF SHIFT.
    BNE  FP_RTLOG1_ROR1     ; LOOP UNTIL DONE.
    RTS           ; RETURN.

; Routine: FP_SWAP
FP_SWAP      ; Original F441
    LDX  #$4      ; INDEX FOR 4 BYTE SWAP (X1,M1 with X2,M2 = 1+3+1+3 bytes, but E is also used)
                  ; The loop swaps X1,M1 (4 bytes) with X2,M2 (4 bytes)
                  ; and E ($FC,FD,FE) gets a copy of original M1 ($F9,FA,FB)
                  ; STY E-1,X is STY $FB,X. If X=$04, $FB+$04 = $FF.
                  ; This means E-1 ($FB) is used as a base for STY.
                  ; X1-1 ($F7) is base for LDA X1-1,X and STY X1-1,X
                  ; X2-1 ($F3) is base for LDY X2-1,X and STA X2-1,X
                  ; This routine swaps X1/M1 with X2/M2 and puts M1 into E.
                  ; Let's simplify to just swap X1/M1 and X2/M2 for now.
                  ; The E copy is used by FDIV.
    LDX #$03      ; Iterate 4 times (0,1,2,3) for Exp+Mant1, Exp+Mant2
FP_SWAP_LOOP:
    LDA $F8,X  ; Load byte from FP1 (X1, M1, M1+1, M1+2)
    PHA                     ; Save it
    LDA $F4,X  ; Load byte from FP2 (X2, M2, M2+1, M2+2)
    STA $F8,X  ; Store into FP1
    PLA                     ; Get original FP1 byte
    STA $F4,X  ; Store into FP2
    DEX
    BPL FP_SWAP_LOOP
    ; For FDIV, M1 (original) needs to be in E.
    ; After swap, original M1 is in M2. So copy M2 to E.
    LDX #$02 ; M2 is 3 bytes
FP_SWAP_COPY_M2_TO_E_LOOP:
    LDA $F5,X
    STA $FC,X
    DEX
    BPL FP_SWAP_COPY_M2_TO_E_LOOP
    RTS

; Routine: ascii_to_petscii

ascii_to_petscii
    ; Input: A contains ASCII character
    ; Output: A contains PETSCII character (lowercase ASCII converted to uppercase PETSCII)
    CMP #'a'
    BCC no_conversion_needed_petscii
    CMP #'z'+1
    BCS no_conversion_needed_petscii
    SEC             ; Ensure Carry is set for SBC
    SBC #$20        ; Convert ASCII 'a'-'z' to PETSCII 'A'-'Z' (e.g. ASCII 'a' (97) - 32 = PETSCII 'A' (65))
no_conversion_needed_petscii
    RTS


; Routine: attribute_error_msg
attribute_error_msg
    LDA #<attribute_error_msg_string
    STA temp_0
    LDA #>attribute_error_msg_string
    STA temp_0+1
    JMP print_string

; Routine: division_by_zero_msg
division_by_zero_msg
    LDA #<division_by_zero_msg_string
    STA temp_0
    LDA #>division_by_zero_msg_string
    STA temp_0+1
    JMP print_string

; Routine: end_program
end_program
    RTS

; Routine: error_handler
error_handler
    STA error_code
    ; Print error message
    ; Load the message pointer
    LDA error_code
    JSR print_error_message
    JMP end_program

; Routine: generic_error_msg
generic_error_msg
    LDA #<error_msg
    STA temp_0
    LDA #>error_msg
    STA temp_0+1
    JMP print_string

; Routine: key_error_msg
key_error_msg
    LDA #<key_error_msg_string
    STA temp_0
    LDA #>key_error_msg_string
    STA temp_0+1
    JMP print_string

; Routine: not_implemented_error_msg
not_implemented_error_msg
    LDA #<not_implemented_error_msg_string
    STA temp_0
    LDA #>not_implemented_error_msg_string
    STA temp_0+1
    JMP print_string

; Routine: overflow_error_msg
overflow_error_msg
    LDA #<overflow_msg
    STA temp_0
    LDA #>overflow_msg
    STA temp_0+1
    JMP print_string

; Routine: print_char

print_char
    ; Input: A = ASCII character
    ; Output: Prints character to screen via KERNAL CHROUT
    ; Modifies: A (CHROUT modifica A)
    ; Preserves: X, Y (CHROUT preserva X, Y)

    JSR ascii_to_petscii    ; Convert A from ASCII to PETSCII. A is now PETSCII.
    JSR chrout              ; Call KERNAL CHROUT routine (address defined in data section)
    RTS


; Routine: print_error_message
print_error_message
    CMP #1
    BNE pem_check_div_zero
    JMP overflow_error_msg
pem_check_div_zero:
    CMP #2
    BNE pem_check_key_not_found
    JMP division_by_zero_msg
pem_check_key_not_found:
    CMP #4
    BNE pem_check_value_error
    JMP key_error_msg
pem_check_value_error:
    CMP #5
    BNE pem_check_type_error
    JMP value_error_msg
pem_check_type_error:
    CMP #6
    BNE pem_check_index_error
    JMP generic_error_msg
pem_check_index_error:
    CMP #7
    BNE pem_check_name_error
    JMP generic_error_msg
pem_check_name_error:
    CMP #8
    BNE pem_check_assertion_error
    JMP generic_error_msg
pem_check_assertion_error:
    CMP #9
    BNE pem_check_attribute_error
    JMP generic_error_msg
pem_check_attribute_error:
    CMP #10
    BNE pem_check_not_implemented_error
    JMP attribute_error_msg
pem_check_not_implemented_error:
    CMP #11
    BNE pem_check_generic_runtime
    JMP not_implemented_error_msg
pem_check_generic_runtime:
    CMP #255
    BNE pem_end_error_message
    JMP generic_error_msg
pem_end_error_message:
    RTS

; Routine: print_string

print_string
    ; Routine to print a string located at the address contained in the var temp_0
    ; Uses ZP locations $FA/$FB for the 16-bit string pointer.
    ; Preserves A and Y registers.
    PHA                     ; Save A
    TYA                     ; Transfer Y to A (to save Y on stack)
    PHA                     ; Push A (which now holds Y's original value)
    LDA temp_0                ; Load LSB of string address from temp_0 (a .word variable)
    STA $FA           ; Store LSB into ZP pointer
    LDA temp_0+1              ; Load high byte of address from temp_0+1
    STA $FB         ; Store MSB into ZP pointer

    LDY #$00                  ; Use Y as the index for LDA (ZP),Y. This Y is local to the loop.
print_loop_ps               ; Renamed label to avoid conflict if routine is included multiple times (though it shouldn't be)
        LDA ($FA),Y ; Use (Indirect),Y addressing with ZP pointer
        BEQ end_print_ps      ; If char is NUL, end.
        JSR print_char          ; print_char preserves A, does not use Y.
        INY                     ; Increment Y
    ; Check if Y wrapped around (very unlikely for typical strings)
    ; If Y becomes 0 after INY, it means we crossed a 256-byte boundary with Y.
    CPY #0
    BNE print_loop_ps       ; If Y is not 0, continue loop within the current 256-byte page
    ; If Y wrapped to 0, it means we printed 256 chars. Increment MSB of ZP pointer.
    INC $FB
    JMP print_loop_ps       ; And continue printing (Y is 0 again for the new page)
end_print_ps
    PLA                     ; Pop original Y value (into A)
    TAY                     ; Transfer A to Y (restoring Y)
    PLA                     ; Pop original A value
    RTS

